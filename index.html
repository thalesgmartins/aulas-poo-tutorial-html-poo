<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thales | POO Doc</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="style.css">

    <link rel="icon" type="image/svg+xml" href="icon.svg">
</head>

<body>
    <header>
        <h1>Atividade Dirigida:  Documentação POO</h1>

        <p>
            Projeto de documentação desenvolvido nas aulas de <code>Programação Orientada à Objetos</code> abordando os conceitos apresentados nas aulas primeiras aulas.
        </p>
    </header>

    <main>
        <div>
            <h2>Por que Programar Orientado a Objetos?</h2>
                
            <p>
                Ao desenvolver software, a <strong>complexidade é um desafio constante</strong>. Conforme nossos projetos crescem, 
                torna-se mais difícil de <i>manter, reutilizar e organizar o código</i>.
            </p>
            
            <p>
                Para resolver esses problemas, surgiu um novo jeito de pensar e estruturar o código: 
                <code>a Programação Orientada a Objetos (POO)</code>.
            </p>
            
            <h3>A solução da POO</h3>
            
            <p>
                A principal mudança é que passamos a <code>abstrair objetos do mundo real</code>  ao criarmos software, implementando soluções mais intuitivas. 
                Deixamos de ver os algoritmos como <strong>funções isoladas</strong> e passamos a organizar eles em torno desses <code>'objetos'</code>.
            </p>
            
            <p>
                Cada objeto tem seus próprios dados e comportamentos que podem ser realizados com esses dados,
                <strong>assim como na vida real</strong>.
            </p>
            
            <p>
                <p>Por exemplo, se pensamos em um objeto <code>'Carro'</code>: Ele tem <i>cor, marca e ano</i> (atributos), e consegue fazer ações como <i>acelerar e frear</i> (métodos).</p>
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-carro.png" alt="Exemplo de poo usando carro">
            
            <h3>E isso funciona mesmo?</h3>
            
            <p>
                Sim! Mas devemos nos apoiar em <strong>quatro conceitos fundamentais</strong> que funcionam em conjunto para criar um código robusto, flexível e organizado. 
                Eles são conhecidos como os <code>4 Pilares da Programação Orientada a Objetos:</code>
            </p>
            
            <ul>
                <li><a href="#documentacao-abstracao">Abstração</a>;</li>
                <li><a href="#documentacao-encapsulamento">Encapsulamento</a>;</li>
                <li><a href="#documentacao-heranca">Herança</a>;</li>
                <li><a href="#documentacao-polimorfismo">Polimorfismo</a>;</li>
            </ul>
        
        </div>

                <div>
            <h2 id="documentacao-abstracao">Anatomia de uma Classe: Desmontando um Caixa Eletrônico</h2>
            
            <p>
                Se objetos são as <code>'coisas'</code> do nosso sistema, então <code>uma classe seria um molde</code> que define como essas coisas são construídas. 
                Nela é determinando quais dados nossos objetos <strong>irão armazenar</strong> e quais ações poderão executar.
            </p>
            
            <p>
                Para entender melhor vamos considerar que temos uma classe <code>Conta</code>, parte de um importante <strong>Caixa Eletrônico</strong>.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-conta-classe.png" alt="Exemplo de uma classe com poo">
            
            <h3>Atributos</h3>
            
            <p>
                Os atributos são as <code>características ou propriedades</code> que definem um objeto. 
                Eles são as variáveis que <strong>armazenam seu estado interno</strong>. 
            </p>
            
            <p>
                No nosso exemplo de uma <code>Conta</code>, os atributos seriam:
            </p>
            
            <ul>
                <li>Número da conta;</li>
                <li>Agência;</li>
                <li>Nome do titular;</li>
                <li>Saldo.</li>
            </ul>

            <img class="img-documentacao" src="images/poo-exemplo-conta-atributos.png" alt="Exemplo de atributos com poo">
            
            <h3>O Construtor</h3>
            
            <p>
                O construtor é um método especial, executado no momento em que um <strong></strong>novo objeto é criado</strong>. 
                Sua função é inicializar os atributos do objeto, garantindo que ele nasça em um estado <code>válido e consistente</code>.
            </p>
            
            <p>
                Por exemplo, o construtor de uma <strong>Conta</strong> pode receber o <i>número e o titular</i> como parâmetros para 
                já criar o objeto com esses dados preenchidos.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-conta-construtor.png" alt="Exemplo de construtor">
            
            <h3>Os Métodos</h3>
            
            <p>
                Os métodos definem o comportamento de um objeto, ou seja, as ações que ele pode executar. Para a nossa Conta, ações comuns seriam:"
            </p>
            
            <ul>
                <li>sacar(valor);</li>
                <li>depositar(valor);</li>
                <li>verificarSaldo();</li>
            </ul>
            
            <p>
                É importante notar que métoros como <code>sacar()</code> não apenas fazem o saque, mas também contém a <i>lógica para verificar se o saldo é suficiente</i>.
            </p>
            
            <h3>A Instância</h3>
            
            <p>
                Se temos um molde com atributos, métodos e um construtor, então podemos finalmente <strong>criar objetos reais</strong>, chamados de <strong>'instâncias'</strong>. 
                Cada instância é uma <code>Conta</code> individual e independente, com seus <strong>próprios valores de atributos</strong>.
            </p>
            
            <code>Conta minhaConta = new Conta(123, "Thales");</code>
            
        </div>

        <div>
            <h2 id="documentacao-encapsulamento">Encapsulamento: A Arte de Proteger e Organizar o Código</h2>

            <p>
                Podemos entender o encapsulamento como uma <code>cápsula protetora</code> ao redor dos dados e comportamentos de um objeto.
                O objetivo é <strong>expor apenas o que é necessário</strong> para a interação com outros objetos. 
            </p>
            
            <p>
                Pensando novamente no nosso <code>Carro</code>, o motorista controla os <strong><i>pedais e o volante</i></strong>, mas ele <code>não precisa saber como funciona a mecânica
                do motor</code>.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-carro-encapsulamento.png" alt="Exemplo de encapsulamento usando carro">

            <p>
                Nesse exemplo, <code>Motorista</code> consegue acessar os métodos <code>Acelerar() e Frear()</code>, mas o encapsulamento cria um <i>"escudo"</i>, e então
                apenas <code>Carro</code> consegue acessar as funções do motor.
            </p>
            
            <h3>Implementando na prática:</h3>
            
            <h4>Modificadores de Acesso</h4>
            
            Para controlar o que fica <strong>'dentro'</strong> e o que fica <strong>'fora'</strong> da cápsula, usamos os <code>modificadores de acesso</code>.
            
            <ul>
                <li><strong>public:</strong> O atributo ou método é acessível de <code>qualquer lugar do código</code>.</li>
                <li><strong>private:</strong> O atributo ou método só pode ser acessado de <code>dentro da própria classe</code>.</li>
                <li><strong>protected:</strong> É parecido com o private, mas também <code>pode ser acessado por classes filhas</code>.</li>
            </ul>
            
            <p>
                No nosso carro, o <strong>volante e a embreagem</strong> seriam atributos <code>públicos</code>, enquanto o <strong>motor</strong> seria um atributo <code>privado</code>.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-carro-publicos-privados.png" alt="Exemplo de metodos privados e publicos">
            
            <h4>Mas e se dados importantes são privados, como interagimos com eles?</h4>
            
            <p> 
                A resposta é simples, através de <strong>métodos públicos</strong> que servem como <i>'porteiros'</i>. 
                Eles permitem ler <code>(get)</code> e modificar <code>(set)</code> os atributos de forma controlada.
            </p>
            
            <ul>
                <li><strong>Getters</strong>: Usados para retornar o valor de um atributo privado.</li>
                <li><strong>Setters:</strong> Usados para alterar o valor de um atributo privado, geralmente incluindo regras e validações.</li>
            </ul>
            
            <img class="img-documentacao" src="images/poo-exemplo-carro-getters-e-setters.png" alt="Exemplo de metodos privados e publicos">

            <h3>Por que usar?</h3>
            
            <p>Adotar o encapsulamento traz benefícios claros para o projeto:</p>
            
            <ul>
                <li><strong>Proteção:</strong> Evita que os dados de um objeto sejam modificados de forma <code>inesperada ou incorreta</code>.</li>
                <li><strong>Facilita a Manutenção:</strong> Permite <strong>alterar a implementação interna</strong> de uma classe <code>sem quebrar os códigos que a utilizam</code>.</li>
                <li><strong>Clareza e Organização:</strong> Agrupa dados e comportamentos que pertencem ao <strong>mesmo contexto</strong>.</li>
            </ul>
        </div>

        <div>
            <h2 id="documentacao-heranca">Herança vs. Composição: Reutilizando Código com Inteligência</h2>
            
            <p>
                <strong>Evitar a repetição</strong> é uma das <strong>chaves</strong> da programação. Dessa forma, A POO nos oferece duas formas de reutilizar e estender funcionalidades: a <code>Herança e a Composição</code>.
            </p>
            
            <h3>A Herança</h3>
            
            <p>
                A <strong>herança</strong> permite que uma nova classe <strong>absorva os atributos e métodos</strong> de uma classe existente. 
                Isso cria uma relação do tipo <code>'é um'</code>. 
            </p>
            
            <p>
                Por exemplo, um <code>Gerente</code> é um <code>Funcionario</code>. Ele tem tudo que um funcionário tem, mas pode adicionar seus próprios comportamentos, como <i>aprovarVerba()</i>.
            </p>
            
            <img class="img-documentacao" src="images/poo-exemplo-gerente-heranca.png" alt="Exemplo de Hrança com gerente e funcionário">
            
            <h3>A Composição</h3>
            
            <p>
                A composição é usada quando um objeto é construído <code>a partir de outros objetos</code>. 
                Em vez de <strong>herdar</strong>, a classe <code>'contém'</code> uma instância de outra classe. Isso cria uma relação do tipo <code>'tem um'</code>. 
            </p>
            
            <p>
                Por exemplo, um <code>Carro</code> <strong></strong>TEM</strong> um <code>Motor</code>. O carro <strong>NÃO É</strong> um motor.
            </p>
            
            <img class="img-documentacao" src="images/poo-exemplo-carro-composicao.png" alt="Exemplo de Encapsulamento com Carro e Motor">

        </div>

        <div>
            <h2 id="documentacao-polimorfismo">Polimorfismo: Múltiplas Formas, Mesma Interface</h2>
            
            <p>
                Quando falamos de polimorfismo, falamos sobre a capacidade de <strong>um objeto ser referenciado de múltiplas formas</strong>.
                Na prática, isso permite que <strong>diferentes objetos</strong> de <strong>diferentes classes</strong>, possam ter <doce>métodos em comum</doce>.
            </p>
            
            <p>
                O <strong>mesmo comando</strong> enviado a objetos diferentes pode resultar em <strong>comportamentos distintos</strong>.
            </p>
            
            <h3>Na Prática</h3>
            
            <p>
                A forma mais comum de polimorfismo é através da <code>sobrescrita de métodos</code> <i><strong>(override)</strong></i>.            
                Isso é'muito utilizado quando criamos uma implementação específica em uma <code>classe filha</code>, que foi definida como padrão na classe mãe.
            </p>
            
            <p>
                Imagine uma classe <code>Animal</code> com um método <code>fazerSom()</code>.
                E que as classes <code>Cachorro</code> e <code>Gato</code> herdam de <code>Animal</code>.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-animal-polimorfismo.png" alt="Exemplo de Encapsulamento Polimorfismo com Animais">
            
            <p>
                Aplicando o polimorfismo, cada uma <i>'sobrescreve'</i> o método <code>fazerSom()</code> para emitir o som correto: <code>'Au au'</code> e <code>'Miau'</code>.
            </p>

            <img class="img-documentacao" src="images/poo-exemplo-animal-polimorfismo2.png" alt="Exemplo de Encapsulamento Polimorfismo com Animais">
            
            <h3>A Vantagem</h3>
            
            <p>
                O poder do polimorfismo está na <strong>flexibilidade</strong>. Podemos criar uma lista de <code>Animal</code> e adicionar <code>Cachorro</code> e <code>Gato</code> a ela. 
                Ao percorrer a lista e chamar <code><i><strong>.fazerSom()</strong></i></code> para cada item, o Java se encarrega de <strong>executar a implementação correta para cada objeto</strong>, 
                sem que precisemos verificar o tipo de cada um.
            </p>
        </div>

        <div>

            <h2>Lidando com o Inesperado: Controle de Exceções</h2>
            
            <p>
                O que acontece quando um usuário tenta <strong>sacar um valor maior que o saldo?</strong> Ou tenta dividir um número por <strong>zero?</strong>
                Em vez de deixar o programa <code>quebrar e fechar</code>, a POO nos dá um mecanismo para capturar e tratar essas situações:
                o <code>Controle de Exceções</code>.
            </p>
            
            <h3>A Estrutura <strong>try-catch-finally</strong></h3>
            
            <p>A principal estrutura para o tratamento de exceções é:</p>
            
            <ul>
                <li><strong>try:</strong> Envolve o trecho de código onde um <code>erro</code> pode ocorrer. É a <strong>tentativa</strong> de executar uma <strong>operação de risco</strong>.</li>
                <li><strong>catch:</strong> Captura a <code>exceção</code>, caso ela ocorra. Se qualquer erro acontecer, esse bloco de código será executado para <strong>tratar o problema de forma controlada</strong>.</li>
                <li><strong>finally:</strong> Esse bloco de código é <code>opctional</code>, mas será <strong>executado ocorrendo um erro ou não</strong>.</li>
            </ul>
            
            <img class="img-documentacao" src="images/poo-exemplo-conta-controle-excessoes.png" alt="Exemplo de Controle de Exceções com Conta Bancária">
            
            <h3>Por que usar?</h3>
            
            <p>
                Utilizar o controle de exceções separa a <code>lógica de negócio</code> do <strong>tratamento de erros</strong>. 
                Isso torna nosso código mais <strong>limpo, legível e robusto</strong>.
            </p>
        </div>

        <div>
            
            <h2>Contratos e Acoplamento:</h2>
            
            <p>
                Imagine que precisamos garantir que várias classes diferentes, como <strong>RelatorioPDF</strong> e <strong>RelatorioExcel</strong>, 
                tenham obrigatoriamente um método <strong>gerar()</strong>. Como podemos forçar esse comportamento?
            </p>
            
            <p>
                A resposta são as <strong>Interfaces</strong>. Uma interface funciona como um 'contrato' que uma classe pode assinar.
                Ao 'implementar' uma interface, a classe se compromete a fornecer uma implementação para todos os métodos definidos no contrato.
            </p>
            
            <h3>Assinando o Contrato</h3>
            
            <p>
                Uma interface apenas define <strong>o quê</strong> uma classe deve fazer, mas não <strong>como</strong>. 
                Uma classe pode implementar várias interfaces, diferente da herança, onde ela só pode herdar de uma única classe.
            </p>
            
            <p>COLOCAR AQUI UM CODIGO COM UMA INTERFACE E UMA CLASSE IMPLEMENTANDO ELA</p>
            
            <h3>A Grande Vantagem: Baixo Acoplamento</h3>
            
            <p>
                O maior poder das interfaces é promover o <strong>baixo acoplamento</strong>. 
                Isso significa que nosso código pode depender do 'contrato' (a interface) em vez de uma classe específica. 
                Assim, podemos trocar as implementações facilmente (hoje usamos PDF, amanhã usamos Excel) sem quebrar o resto do sistema. 
                Isso torna o software flexível e adaptável.
            </p>
        </div>

        <div>
            <h2>Vale a Pena Programar Orientado a Objetos?</h2>
            
            <p>
                Ao longo desta documentação, exploramos os conceitos que fazem da POO um dos paradigmas mais importantes do mercado.
                Vimos como organizar o código em classes, protegê-lo com encapsulamento, reutilizá-lo com herança e composição,
                e torná-lo flexível com polimorfismo e interfaces.
            </p>
            
            <p>
                Então, vale a pena? <strong>Com certeza.</strong> A POO não é só um conjunto de regras, mas uma mentalidade que nos treina
                para construir sistemas mais organizados, modulares e fáceis de manter. Dominar seus pilares é um passo essencial
                para escrever software de alta qualidade, preparado para crescer e evoluir com o tempo.
            </p>
        </div>

    </main>
</body>
</html>